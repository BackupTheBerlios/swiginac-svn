<?xml version="1.0" encoding="iso-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Symbolic Computation with GiNaC and Python</title>
<meta name="date" content="2007-02-01" />
<meta name="copyright" content="2006 Guenter Milde. Released under the terms of the GNU General Public License (v. 2 or later)" />
<link rel="stylesheet" href="../../../../../../.python/docutils-svn/docutils/docutils/writers/html4css1/html4css1.css" type="text/css" />
</head>
<body>
<div class="document" id="symbolic-computation-with-ginac-and-python">
<h1 class="title">Symbolic Computation with GiNaC and Python</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Version:</th>
<td>1.3.5</td></tr>
<tr><th class="docinfo-name">Status:</th>
<td>draft</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2007-02-01</td></tr>
<tr><th class="docinfo-name">Copyright:</th>
<td>2006 Guenter Milde.
Released under the terms of the GNU General Public License
(v. 2 or later)</td></tr>
</tbody>
</table>
<div class="abstract topic">
<p class="topic-title first">Abstract</p>
<p>Using the GiNaC open framework for symbolic computation within
the Python programming language</p>
</div>
<!-- Bibliographic Fields -->
<!-- :Author: Guenter Milde -->
<!-- :Organization: organization. -->
<!-- :Contact: contact. -->
<!-- :Address: address. -->
<!-- :Dedication: topic. -->
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#introduction" id="id8">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#a-tour-of-ginac" id="id9">2&nbsp;&nbsp;&nbsp;A Tour of GiNaC</a><ul class="auto-toc">
<li><a class="reference internal" href="#how-to-use-it-from-within-python" id="id10">2.1&nbsp;&nbsp;&nbsp;How to use it from within Python</a></li>
<li><a class="reference internal" href="#what-it-can-do-for-you" id="id11">2.2&nbsp;&nbsp;&nbsp;What it can do for you</a><ul class="auto-toc">
<li><a class="reference internal" href="#symbols" id="id12">2.2.1&nbsp;&nbsp;&nbsp;Symbols</a></li>
<li><a class="reference internal" href="#numbers" id="id13">2.2.2&nbsp;&nbsp;&nbsp;Numbers</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#installation" id="id14">3&nbsp;&nbsp;&nbsp;Installation</a><ul class="auto-toc">
<li><a class="reference internal" href="#id1" id="id15">3.1&nbsp;&nbsp;&nbsp;GiNaC</a></li>
<li><a class="reference internal" href="#id5" id="id16">3.2&nbsp;&nbsp;&nbsp;swiginac</a></li>
<li><a class="reference internal" href="#pyginac" id="id17">3.3&nbsp;&nbsp;&nbsp;PyGiNaC</a></li>
<li><a class="reference internal" href="#source" id="id18">3.4&nbsp;&nbsp;&nbsp;Source</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id8">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>This tutorial is intended for the novice user who is new to <a class="reference external" href="http://www.ginac.de">GiNaC</a> but
already has some background in Python programming. It is an adaption of the
<a class="reference external" href="http://www.ginac.de/tutorial/">GiNaC tutorial</a> (for symbolic computation within the C++ programming
language) for computer algebra with <a class="reference external" href="http://www.ginac.de">GiNaC</a> and the <a class="reference external" href="http://www.python.org">Python</a> programming
language using the <a class="reference external" href="http://swiginac.berlios.de">swiginac</a> wrapper package.</p>
<p>This tutorial only covers the basics, the original <a class="reference external" href="http://www.ginac.de/tutorial/">GiNaC tutorial</a>
says</p>
<blockquote>
... since a hand-made documentation like this one is difficult to
keep in sync with the development, the actual documentation is
inside the sources in the form of comments. That documentation may
be parsed by one of the many Javadoc-like documentation systems. If
you fail at generating it you may access it from the <a class="reference external" href="http://www.ginac.de">GiNaC</a> home
page. It is an invaluable resource not only for the advanced user
who wishes to extend the system (or chase bugs) but for everybody
who wants to comprehend the inner workings of GiNaC. This little
tutorial on the other hand only covers the basic things that are
unlikely to change in the near future.</blockquote>
<p>The examples in this tutorial assume a working installation of GiNaC
and the swiginac package (see the <a class="reference internal" href="#installation">Installation</a> chapter for how to get
there).</p>
</div>
<div class="section" id="a-tour-of-ginac">
<h1><a class="toc-backref" href="#id9">2&nbsp;&nbsp;&nbsp;A Tour of GiNaC</a></h1>
<p>This quick tour of GiNaC wants to arise your interest in the subsequent
chapters by showing off a bit.</p>
<p>Please excuse us if it leaves many open questions.</p>
<div class="section" id="how-to-use-it-from-within-python">
<h2><a class="toc-backref" href="#id10">2.1&nbsp;&nbsp;&nbsp;How to use it from within Python</a></h2>
<p>Neither <a class="reference external" href="http://www.ginac.de">GiNaC</a> nor <a class="reference external" href="http://swiginac.berlios.de">swiGiNaC</a> define a language of their own as conventional
computer algebra systems do. Instead, swiGiNaC converts GiNaC into an open
framework for symbolic computation within the Python programming language</p>
<p>Here is how to generate and print a simple (and rather pointless) bivariate
polynomial with some large coefficients:</p>
<pre class="literal-block">
from swiginac import *

def bipol():
    x = symbol('x')
    y = symbol('y')

    poly = 0
    for i in xrange(3):
         poly += factorial(i+16) * x**i * y**(2-i)

    return poly
</pre>
<p>Now we can import the function and try it out:</p>
<pre class="doctest-block">
&gt;&gt;&gt; from swiginac_tutorial import bipol
&gt;&gt;&gt; print bipol()
355687428096000*y*x+20922789888000*y**2+6402373705728000*x**2
</pre>
<p>Next, there is a more meaningful function that generates Hermite polynomials
in a specified free variable:</p>
<pre class="literal-block">
def HermitePoly(x, n):
     HKer = exp(-x**2)
     # uses the identity H_n(x) == (-1)^n exp(x^2) (d/dx)^n exp(-x^2)
     return normal((-1)**n * 1/HKer * diff(HKer, x, n))
</pre>
<p>When run, this will type out the Hermite polynomials as symbolic terms:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from ginac-tutorial import HermitePoly
&gt;&gt;&gt; z = symbol(&quot;z&quot;);
&gt;&gt;&gt; for i in xrange(6):
...     print &quot;H_%d(z) == %s&quot;%(i, HermitePoly(z,i))
H_0(z) == 1
H_1(z) == 2*z
H_2(z) == -2+4*z**2
H_3(z) == -12*z+8*z**3
H_4(z) == 12+16*z**4-48*z**2
H_5(z) == 120*z+32*z**5-160*z**3
</pre>
</blockquote>
<p>This method of generating the coefficients is of course far from optimal for
production purposes.</p>
</div>
<div class="section" id="what-it-can-do-for-you">
<h2><a class="toc-backref" href="#id11">2.2&nbsp;&nbsp;&nbsp;What it can do for you</a></h2>
<p>In order to show some more examples of GiNaC at work, the original tutorial
uses the <cite>GiNaC interactive shell</cite> <tt class="docutils literal"><span class="pre">ginsh</span></tt>. The simple <tt class="docutils literal"><span class="pre">ginsh</span></tt> shell
does not provide programming constructs like loops or conditionals, whereas
<cite>swiginac</cite> combines the symbolic capacities of <a class="reference external" href="http://www.ginac.de">GiNaC</a> with the ease of use
and the power of the full grown and established programming language
<a class="reference external" href="http://www.python.org">Python</a>.</p>
<p>After starting a python interpreter, import the <cite>swiginac</cite> module with:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from swiginac import *
</pre>
</blockquote>
<p>Now you can test and experiment with GiNaC's features much like in other
Computer Algebra Systems.</p>
<div class="section" id="symbols">
<h3><a class="toc-backref" href="#id12">2.2.1&nbsp;&nbsp;&nbsp;Symbols</a></h3>
<p>One main difference between &quot;normal&quot; CAS systems (or ginsh) and computer
algebra with Python is the need to define any symbols before use. Otherwise
Python will complain about unidentified variables:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; sin(x)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in ?
NameError: name 'x' is not defined
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; x = symbol('x')
&gt;&gt;&gt; sin(x)
sin(x)
</pre>
</blockquote>
<p>OTOH, it is easy to use define a set of symbols in a function:</p>
<pre class="literal-block">
import sys
def new_symbol(*names, **kwargs):
    &quot;&quot;&quot;Create symbolic variables for all names in the argument list

    and bind them in the namespace of the `__main__` module

    A keyword argument `obj` is interpreted as an object where the new
    symbols should be bound, e.g.
    ``new_symbol('name1', 'name2', ..., obj=sys.modules[__name__])``
    binds in the calling modules namespace even if this is not `__main__`.
    &quot;&quot;&quot;
    obj=kwargs.get('obj', sys.modules['__main__'])
    for name in names:
        setattr(obj, name, symbol(name))
</pre>
<p>and use this, e.g. to make all single lowercase letters symbols:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; import string
&gt;&gt;&gt; new_symbol(*[name for name in string.lowercase])
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; type(u)
&lt;class 'swiginac.symbol'&gt;
</pre>
</blockquote>
</div>
<div class="section" id="numbers">
<h3><a class="toc-backref" href="#id13">2.2.2&nbsp;&nbsp;&nbsp;Numbers</a></h3>
<p>The <tt class="docutils literal"><span class="pre">numeric</span></tt> class can manipulate arbitrary precision integers in a very
fast way. Rational numbers are automatically converted to fractions of
coprime integers. As by default Python will convert a number to one of its
internal numerical data types, it is necessary to specify the wish to treat
a number as arbitrary precision integer. In an expression, it is often
sufficient to define just one numeric value as instance of the numeric class:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; x = numeric(3)**150
&gt;&gt;&gt; print x
369988485035126972924700782451696644186473100389722973815184405301748249
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; y = numeric(3)**149
&gt;&gt;&gt; print y
123329495011708990974900260817232214728824366796574324605061468433916083
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print x/y
3
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print y/x
1/3
</pre>
</blockquote>
<p>When specifying rational numbers, the expression that is the argument
to <cite>numeric</cite> is evaluated using Pythons &quot;standard&quot; arithmetic, which is
probabely not what we want:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print numeric(1/3)
0
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print numeric(1./3)
0.33333333333333331483
</pre>
</blockquote>
<p>To prevent evaluation by the &quot;normal&quot; Python operators, rational numbers can
be input as string value or as (numerator, denominator) tuple:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; print numeric(&quot;1/3&quot;)
1/3
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print numeric(1, 3)
1/3
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; print numeric(3, 9)
1/3
</pre>
</blockquote>
<p>Exact numbers are always retained as exact numbers and only evaluated as
floating point numbers if requested. For instance, products of sums of
radicals can be expanded:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = symbol('a')
&gt;&gt;&gt; expand((1+a**numeric('1/5')-a**numeric('2/5'))**3)
1-a**(6/5)+3*a**(1/5)-5*a**(3/5)+3*a
</pre>
</blockquote>
<p>Numeric radicals are dealt pretty much as symbols:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; expand((1+3**numeric('1/5')-3**numeric('2/5'))**3)
10-5*3**(3/5)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; ((1+3**numeric('1/5')-3**numeric('2/5'))**3).evalf()
0.33408977534118624228
</pre>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">evalf()</span></tt> method used above converts any number in GiNaC's expressions
into floating point numbers:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; numeric('1/7').evalf()
0.14285714285714285714
</pre>
</blockquote>
<div class="note">
<p class="first admonition-title">Note</p>
<dl class="docutils">
<dt>In GiNaC or ginsh, this can be done to arbitrary predefined</dt>
<dd><blockquote class="first">
accuracy:</blockquote>
<p class="last">&gt; Digits=150;
150
&gt; evalf(1/7);
0.1428571428571428571428571428571428571428571428571428571428571428571428</p>
</dd>
</dl>
<p class="last">I did not find an equivalent setting in swiginac, though. Either this is
not available (yet) or I just did not find it.</p>
</div>
<p>The return value of <tt class="docutils literal"><span class="pre">evalf()</span></tt> is still a <tt class="docutils literal"><span class="pre">numeric</span></tt> value:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(numeric('1/7').evalf())
&lt;class 'swiginac.numeric'&gt;
</pre>
</blockquote>
<p>You can convert it to a Python datatype by the usual Python means or
using the <tt class="docutils literal"><span class="pre">to_double()</span></tt>, <tt class="docutils literal"><span class="pre">to_int()</span></tt>, or <tt class="docutils literal"><span class="pre">to_long()</span></tt> methods:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; type(numeric('1/7').to_double())
&lt;type 'float'&gt;
</pre>
</blockquote>
<p>Exact numbers that can be manipulated in GiNaC include predefined constants
like Archimedes' Pi. They can both be used in symbolic manipulations (as an
exact number) as well as in numeric expressions (as an inexact number):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; x = symbol('x')
&gt;&gt;&gt; a = Pi**2 + x
&gt;&gt;&gt; print a
Pi**2+x
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a.evalf()
9.869604401089358619+x
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; a.subs(x == 2).evalf()
11.869604401089358619
</pre>
</blockquote>
<div class="note">
<p class="first admonition-title">Note</p>
<p>The <tt class="docutils literal"><span class="pre">subs()</span></tt> method is used, as changing the value of <tt class="docutils literal"><span class="pre">x</span></tt> will
not propagate to the already defined expression <tt class="docutils literal"><span class="pre">a</span></tt>:</p>
<blockquote class="last">
<pre class="doctest-block">
&gt;&gt;&gt; x = 2
&gt;&gt;&gt; a.evalf()
9.869604401089358619+x
</pre>
</blockquote>
</div>
<p>Built-in functions evaluate immediately to exact numbers if this is
possible. Conversions that can be safely performed are done immediately;
conversions that are not generally valid are not done:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; x = symbol('x')
&gt;&gt;&gt; cos(42*Pi)
1
&gt;&gt;&gt; cos(acos(x))
x
&gt;&gt;&gt; acos(cos(x));
acos(cos(x))
</pre>
</blockquote>
<p>(Note that converting the last input to x would allow one to conclude that
42*Pi is equal to 0.)</p>
<p>Linear equation systems can be solved along with basic linear algebra
manipulations over symbolic expressions. swiginac offers a matrix
class for this purpose:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; x = symbol('x')
&gt;&gt;&gt; y = symbol('y')
&gt;&gt;&gt; z = symbol('z')
&gt;&gt;&gt; a = symbol('a')
&gt;&gt;&gt; b = symbol('b')
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; lsolve(a+x*y==z,x)
y**(-1)*(z-a)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; lsolve([3*x+5*y == 7, -2*x+10*y == -5], [x, y])
[x==19/8, y==-1/40]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; M = matrix([[1, 3], [-3, 2]])
&gt;&gt;&gt; determinant(M);
11
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; l = symbol('lambda', '\lambda')  # lambda is a Python keyword
&gt;&gt;&gt; charpoly(M,l)
11-3*lambda+lambda**2
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; A = matrix([[1, 1], [2, -1]])
&gt;&gt;&gt; A + 2*M
[[1,1],[2,-1]]+2*[[1,3],[-3,2]]
&gt;&gt;&gt; evalm(A + 2*M)
[[3,7],[-4,3]]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; B = matrix([[0, 0, a], [b, 1, -b], [-1/a, 0, 0]])
&gt;&gt;&gt; evalm(B**(2**12))
[[1,0,0],[0,1,0],[0,0,1]]
</pre>
</blockquote>
<p>Multivariate polynomials and rational functions may be expanded, collected
and normalized (i.e. converted to a ratio of two coprime polynomials):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; a = x**4 + 2*x**2*y**2 + 4*x**3*y + 12*x*y**3 - 3*y**4
&gt;&gt;&gt; b = x**2 + 4*x*y - y**2
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; expand(a*b)
3*y**6+8*y*x**5+16*y**3*x**3+x**6+43*y**4*x**2-24*y**5*x+17*y**2*x**4
&gt;&gt;&gt; collect(a+b,x)
(1+2*y**2)*x**2-3*y**4+x**4+x*(4*y+12*y**3)+4*y*x**3-y**2
&gt;&gt;&gt; collect(a+b,y)
12*y**3*x-3*y**4+x**4+(-1+2*x**2)*y**2+x**2+y*(4*x+4*x**3)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; normal(a/b)
x**2+3*y**2
</pre>
</blockquote>
<p>You can differentiate functions and expand them as Taylor or Laurent series
in a very natural syntax (the second argument of series is a relation
defining the evaluation point, the third specifies the order):</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; diff(tan(x),x)
1+tan(x)**2
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; series(sin(x),x==0,4)
1*x+(-1/6)*x**3+Order(x**4)
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; series(1/tan(x),x==0,2)
1*x**(-1)+(-1/3)*x+Order(x**2)
</pre>
<p>series(tgamma(x),x==0,2)
1*x**(-1)+(-Euler)+(1/12*Pi**2+1/2*Euler**2)*x+Order(x**2)</p>
<p>series(tgamma(x),x==0,2).evalf()
1.0*x**(-1)+(-0.5772156649015328606)+0.9890559953279725555*x+Order(x**2)</p>
<pre class="doctest-block">
&gt;&gt;&gt; series(tgamma(2*sin(x)-2),x==Pi/2,3)
(-1)*(-1/2*Pi+x)**(-2)+(-1/12-Euler)+(-1/240-1/12*Pi**2-1/2*Euler**2)*(-1/2*Pi+x)**2+Order((-1/2*Pi+x)**3)
</pre>
</blockquote>
<p>Often, functions don't have roots in closed form. Nevertheless, GiNaC can
compute a solution numerically:</p>
<blockquote>
TODO: is there an equivalent to fsolve in swiginac?</blockquote>
<p>Symbolic types can always be used as tags for different types of objects.
Converting from &quot;wrong&quot; units to the metric system is an example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; new_symbol('m', 'kg', 'lb', 'inch')
&gt;&gt;&gt; inch = .0254*m
&gt;&gt;&gt; lb = .45359237*kg
&gt;&gt;&gt; 200*lb/inch**2
(140613.91592783187407)*kg*m**(-2)
</pre>
</blockquote>
<p>BTW, the <em>Scientific.Physics.PhysicalQuantities</em> module from the <a class="reference external" href="http://dirac.cnrs-orleans.fr/ScientificPython/">Scientific</a>
package provides an elaborated environment specifically designed for working
with units.</p>
</div>
</div>
</div>
<div class="section" id="installation">
<h1><a class="toc-backref" href="#id14">3&nbsp;&nbsp;&nbsp;Installation</a></h1>
<p>Installation is covered in the original documentation of the relevant
packages. Instead of repeating it, just pointers will be given.</p>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id15">3.1&nbsp;&nbsp;&nbsp;GiNaC</a></h2>
<p>The GiNaC framework for symbolic computation within the C++ programming
language (and its tutorial) is Copyright 1999-2006 Johannes Gutenberg
University Mainz, Germany. It is released under the
<a class="reference external" href="http://www.gnu.org/copyleft/gpl.html">GNU General Public License</a> (GPL).</p>
<p><a class="reference external" href="http://www.ginac.de">GiNaC</a> sources can be fetched from its home site under the section
<a class="reference external" href="http://www.ginac.de/Download.html">Download GiNaC now</a> which also says:</p>
<blockquote>
Since GiNaC is packaged by a couple of software distributors, you may want
to try a conveniently packaged binary first (but please don't send us
bug-reports about these packages since they may be outdated). We are
currently aware of packages in <a class="reference external" href="http://www.ginac.de/tutorial/Installation.html#Installation">Debian</a>, SuSE, Mandrake, Fedora, and
FreeBSD.</blockquote>
<p>The <a class="reference external" href="http://packages.qa.debian.org/g/ginac.html">installation</a> is covered in the <a class="reference external" href="http://www.ginac.de/tutorial/">GiNaC tutorial</a> (and in the INSTALL
file of the tarball).</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id16">3.2&nbsp;&nbsp;&nbsp;swiginac</a></h2>
<p><a class="reference external" href="http://swiginac.berlios.de">swiginac</a> is a Python interface to GiNaC, built with <a class="reference external" href="http://www.swig.org/">SWIG</a>. The aim of
swiginac is to make the functionality of GiNaC accessible from Python as
an extension module.</p>
<p>Current status is beta; a lot (but not all yet) of the GiNaC classes are
exposed, virtually all of the GiNaC tests pass.</p>
<p>For more information, documentation and software downloads, visit the
<a class="reference external" href="http://developer.berlios.de/projects/swiginac/">swiginac group pages on BerliOS</a>.</p>
<p>The <a class="reference external" href="http://developer.berlios.de/project/filelist.php?group_id=4761">source tarballs</a> contains installation instructions in a
INSTALL.txt file.</p>
</div>
<div class="section" id="pyginac">
<h2><a class="toc-backref" href="#id17">3.3&nbsp;&nbsp;&nbsp;PyGiNaC</a></h2>
<p><a class="reference external" href="http://pyginac.sourceforge.net/">PyGiNaC</a> is another Python package that provides an interface to the C++
library GiNaC. PyGiNaC is implemented with the help of the <a class="reference external" href="http://www.boost.org/libs/python/doc/index.html">Boost.Python</a>
library. At the moment, the package is more or less in an &quot;alpha&quot; state,
i.e. the GiNaC classes are only partially exposed, parts of regression test
suite are unconverted and no actual documentation exists. However, all of
this is supposed to change in the future.</p>
<p>At the moment there are no released tarballs of PyGiNaC. Instead, it can be
downloaded directly from the CVS repository at SourceForge. (See the
<a class="reference external" href="http://pyginac.sourceforge.net/">PyGiNaC</a> page for instructions.)</p>
</div>
<div class="section" id="source">
<h2><a class="toc-backref" href="#id18">3.4&nbsp;&nbsp;&nbsp;Source</a></h2>
<p>The <a class="reference external" href="http://svn.berlios.de/svnroot/repos/swiginac/trunk/doc/ginac-tutorial.py.txt">source of this tutorial</a> is written in <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructured Text</a>. To
translate it, you need the Python <a class="reference external" href="http://docutils.sourceforge.net/rst.html">docutils</a>. With docutils installed,
the command <tt class="docutils literal"><span class="pre">rst2html</span> <span class="pre">ginac-tutorial.py.txt</span></tt> will produce the html
file, while <tt class="docutils literal"><span class="pre">rst2pdf.py</span> <span class="pre">ginac-tutorial.py.txt</span></tt> will produce a PDF
version.</p>
<p>The bidirectional text &lt;-&gt; code converter <a class="reference external" href="http://pylit.berlios.de">PyLit</a> can be used to
transform the tutorial source to a Python module providing the example
functions and to run the examples in a doctest. (This is why it has the
<tt class="docutils literal"><span class="pre">.py.txt</span></tt> double extension.)</p>
</div>
</div>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="swiginac_tutorial.py.txt">View document source</a>.

</div>
</body>
</html>
